% Meridian 59, Copyright 1994-2012 Andrew Kirmse and Chris Kirmse.
% All rights reserved.
%
% This software is distributed under a license that is described in
% the LICENSE file that accompanies it.
%
% Meridian is a registered trademark.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ChainHeal is Heal

constants:

   include blakston.khd

resources:

   chainheal_name_rsc = "chain heal"
   chainheal_icon_rsc = iheal.bgf
   chainheal_desc_rsc = \
      "Chain Heal Debugging. Takes herbs and emeralds."
     
   chainheal_spell_intro = \
      "Shal'ille Lv. 7: Heals the target then finds more allies."

      test_rsc = "Chain Heal lTargets"
      test_rsc2 = "Chain Heal lActive"
     
classvars:
   
   vrName = chainheal_name_rsc
   vrIcon = chainheal_icon_rsc
   vrDesc = chainheal_desc_rsc
   vrProjectile_icon = lightning_icon_rsc
   
   vrTestRsc = test_rsc
   vrTestRsc2 = test_rsc2
   
   % vrCastSelf = chainheal_cast_self
   % vrCastOther = chainheal_cast_rsc
   vrSpell_intro = chainheal_spell_intro

   viProjectileFlag = PROJ_FLAG_LIGHT_SOURCE
   
   viSpell_num = SID_CHAIN_HEAL
   viMana = 5
   viSchool = SS_SHALILLE
   viPersonal_ench = FALSE
   viSpell_level = 7
   viChance_To_Increase = 95
   viMeditate_ratio = 100
   
properties:

   %timers
   ptCooldown
   ptNextHeal
   
   %timer values
   piNextHeal_delay = 10000

   piMaxPlayersHealed = 5
   
   %list of  all players to be healed
   poFirst
   poSecond
   pbDone = FALSE
   
   %debug flags for lighting effects
   pbLogs = FALSE
   pbDebug = FALSE
   piDebugSpeed = 3
   piDebugColor = 1
   piIntensity = 100
   piLightFlags = 1
   piRepeatProjectiles = 1
   piDebugSpellpower = 1
   
messages:

   ResetReagents()
   {
      % separate message so can change, then set from admin mode
      plReagents = $;
      plReagents = Cons([&Herbs,3],plReagents);
      plReagents = Cons([&Emerald,3],plReagents);
      %plReagents = Cons([&OrcTooth,3],plReagents);

      return;
   }
   
   %%%%%%%%%%%%%
   %   Cast on 1 target (possibly yourself) to instantly heal that target, then wait
   %   a variable delay before healing the next target (and sending animation from T1 to T2)
   %   ...variable delay before healing the Next target (and sending animation from T2 to T3)...
   %   
   %   So the initial idea was to use a timer for the delay between heal procs (ptNextHeal)
   %   That does not work because only 1 instance of the spell is created so each cast re-inits that same timer
   %   
   %   It was suggested to reference boon.kod how it handles 'extended' enchantments
   %   This seemed good and would essentially work by making a list of all targets
   %   (plTargets) that would get passed through StartEnchantment() and EndEnchanment()
   %   so we could track which player would be effected next. 
   %   EndEnchantment() would call StartEnchantment() on the next object in the list.
   %   
   %   Further research leads to this causing errors in how enchantments are handled - specifically
   %   because of FreezeAllEnchantments() called when a player logs off- 
   %   This is bad because if a player is healed, and logs off before it fires again do we fail out? Or try to terminate
   %   the delay early (delay won't be long enough to make this effective in 'gaming' it) and just heal the next target
   %   
   %   I don't want to start pulling apart / modifying enchantment code in player.kod
   %   
   %%%%%%%%%%%%%
   %   Make a DelayedEffect class of spells
   %   Add to player.kod plDelayedSpellTimers
   %   Any DelayedEffect spell created will have a unique index into the Timers array
   %   Players can only be under the effect of a given DelayedEffect spell once, and additional casts
   %   can either be ignored, or increase power/duration (depends on what the effect is) which is handled in
   %   that unique spells class. So for ChainHeal we would want to ignore an additional cast, OR
   %   the list of timers is a list of list of timers but we only run the first one. So someone can spam chain heal on you, assuming they can cast faster
   %   than the delay of ptNextHeal, so it queues up the timers and only the first one runs.
   %%%%%%%%%%%%%
   %   We're going back to the suggested idea of EndEnchantment calling StartEnchantment on the next target - info passed via iState
   %%%%%%%%%%%%%
   
   CastSpell(who=$,lTargets=$,iSpellPower=0)
   {
      local i, each_obj, lFinalTargets, oTarget, numProjectiles, index, lState, iIterations, iHealthPool, oRoom, lActive;

      oTarget = First(lTargets);
      numProjectiles = 0;
      index = 1;
      %%%Will probably need to do a last minute check that the target is still in the room - skip them if they're not
     
      if iSpellPower < 20
      {
         iIterations = 3;
         iHealthPool = 4500;
      }
      else if iSpellPower < 40
      {
         iIterations = 4;
         iHealthPool = 6000;
      }
      else if iSpellPower < 60
      {
         iIterations = 5;
         iHealthPool = 10000;
      }
      else if iSpellPower < 80
      {
         iIterations = 6;
         iHealthPool = 15000;
      }
      else
      {
         iIterations = 7;
         iHealthPool = 17500;
      }
	  
      if pbLogs = TRUE
      {
         Debug("oTarget = ",oTarget);
         Debug("iIterations = ",iIterations);
         Debug("iHealthPool = ",iHealthPool);
         % Debug("pbDebugSpeed = ",piDebugSpeed,"\npbDebugColor = ",piDebugColor);
         % Debug("piIntensity = ",piIntensity,"\npiLightFlags = ",piLightFlags);
      }

	  iHealthPool = iHealthPool - Send(oTarget,@GainHealthNormal,#amount=2000,#precision=TRUE);
	  
      lState = AppendListElem(iIterations,lState);			% remaining iterations
      lState = AppendListElem(iHealthPool,lState);			% points remaining to heal from
      lState = AppendListElem(piNextHeal_delay,lState);	% time to wait before next heal
      lState = AppendListElem(who,lState);					% who cast the spell
      lState = AppendListElem(oTarget,lState);				% who has been healed so far

	  
      Send(oTarget,@StartEnchantment,#what=self,#time=piNextHeal_delay,#state=lState);
     
      propagate;
   }

   EndEnchantment(who = $, state = 0, report = TRUE)
   {
      local iIterations, iHealthPool, iDelay, oCaster, lHealed, lStateInfo, oNextTarget;
      %% This will handle actually finding the next target, healing that target, and starting the delay on that target.
      %% state will hold a list with the structure [[RemainingIterations],[Delay],[OriginalCaster],[TargetsHealed(in order)]]
      %% For consideration: Store the room it was cast in, and fail out of we've left the room?
      lStateInfo = state;
     
      iIterations = First(lStateInfo);
      lStateInfo = DelListElem(lStateInfo,First(lStateInfo));

      iHealthPool = First(lStateInfo);
      lStateInfo = DelListElem(lStateInfo,First(lStateInfo));
     
      iDelay = First(lStateInfo);
      lStateInfo = DelListElem(lStateInfo,First(lStateInfo));
     
      oCaster = First(lStateInfo);
      lStateInfo = DelListElem(lStateInfo,First(lStateInfo));
     
      lHealed = First(lStateInfo); %goes from a list with 1 element that is a list of objects to just a list of objects.
      lStateInfo = DelListElem(lStateInfo,First(lStateInfo));
     
      if pbLogs = TRUE
      {
         Debug("---ENDING ENCHANTMENT---");
         Debug("iIterations = ",iIterations);
         Debug("iHealthPool = ",iHealthPool);
         % Debug("iDelay = ",iDelay);
         Debug("oCaster = ",oCaster);
         Debug("lHealed = ",lHealed);
      }
     
      iIterations--;

      if iIterations <> 0
      {
         oNextTarget = Send(self,@DetermineTargets,#who=oCaster,#lHealed=lHealed);
         if(oNextTarget <> $)
         {
            iHealthPool = iHealthPool - Send(oNextTarget,@GainHealthNormal,#amount=2000,#precision=TRUE);
            lStateInfo = AppendListElem(iIterations,lStateInfo);		% remaining iterations
            lStateInfo = AppendListElem(iHealthPool,lStateInfo);    % points remaining to heal from
            lStateInfo = AppendListElem(iDelay,lStateInfo);   	 	% time to wait before next heal
            lStateInfo = AppendListElem(oCaster,lStateInfo);    	% who cast the spell
            lStateInfo = AppendListElem(lHealed,lStateInfo);    		% who has been healed so far
            Send(oNextTarget,@StartEnchantment,#what=self,#time=iDelay,#state=lStateInfo);
         }
         else
         {
            Debug("Nothing left to heal");
         }
      }

      return;
   }
   
   
   DetermineTargets(who=$,lHealed=$)
   {
      local oTarget, oRoom, lActive, lTargets, i, eachObj, tGuild, pGuild, search;

      oTarget = $;
      oRoom = Send(who,@GetOwner);
      lActive = Send(oRoom,@GetHolderActive);
      pGuild = Send(who,@GetGuild);
      search = 1;
     
      
      while search <= 5
      {
         switch(search)
         {
            case 1: %looking for guildmates of who (oCaster) that have not been healed (not in lHealed)
               if pGuild <> $
               {
                  foreach i in lActive
                  {
                     eachObj = Send(oRoom,@HolderExtractObject,#data=i);
                     if (eachObj <> who) AND (FindListElem(lHealed,eachObj)  = $) %not the caster, and has not been healed
                     {
                        if IsClass(eachObj,&User)
                        {
                           tGuild = Send(eachObj,@GetGuild);
                           %%Check guild relations
                           if tGuild <> $
                           {
                              if pGuild = tGuild
                              {
                                 Debug("Found guildmate that was not healed yet");
                                 oTarget = eachObj;
								 search = 6;
								 break;
                              }
                           }
                        }
                     }
                  }
               }
            break;
            case 2: %looking for members of ally guild of who (oCaster) that have not been healed (not in lHealed)
               if pGuild <> $
               {
                  foreach i in lActive
                  {
                     eachObj = Send(oRoom,@HolderExtractObject,#data=i);
                     if (eachObj <> who) AND (FindListElem(lHealed,eachObj)  = $) %not the caster, and has not been healed
                     {
                        if IsClass(eachObj,&User)
                        {
                           tGuild = Send(eachObj,@GetGuild);
                           %%Check guild relations
                           if tGuild <> $
                           {
                              if Send(pGuild,@IsAlly,#otherguild=tGuild) %we only care if You consider Them an ally, not the other way around
                              {
                                 Debug("Found someone in ally guild that was not healed yet");
                                 oTarget = eachObj;
								 search = 6;
								 break;
                              }
                           }
                        }
                     }
                  }
               }
            break;
            case 3: %looking for same faction soldiers of who (oCaster) that have not been healed (not in lHealed)
               if Send(who,@GetFaction) <> $
               {
                  foreach i in lActive
                  {
                     eachObj = Send(oRoom,@HolderExtractObject,#data=i);
                     if (eachObj <> who) AND (FindListElem(lHealed,eachObj)  = $) %not the caster, and has not been healed
                     {
                        if IsClass(eachObj,&User)
                        {
                           if (Send(eachObj,@GetFaction) = Send(who,@GetFaction))
                           {
                              Debug("Found faction member that was not healed yet");
                              oTarget = eachObj;
                              search = 6;
                              break;
                           }
                        }
                     }
                  }
               }
            break;
            case 4: %looking for same faction non-soldiers of who (oCaster) that have not been healed (not in lHealed)
               if Send(who,@GetFaction) <> $
               {
                  foreach i in lActive
                  {
                     eachObj = Send(oRoom,@HolderExtractObject,#data=i);
                     if (eachObj <> who) AND (FindListElem(lHealed,eachObj)  = $) %not the caster, and has not been healed
                     {
                        if IsClass(eachObj,&User)
                        {
                           if (Send(eachObj,@GetFaction) = Send(who,@GetFaction))
                           {
                              Debug("Found faction member that was not healed yet");
                              oTarget = eachObj;
                              search = 6;
                              break;
                           }
                        }
                     }
                  }
               }
            break;
            case 5: %looking for any non-enemies of who (oCaster) that have not been healed (not in lHealed)
               if NOT Send(eachObj,@CheckPlayerFlag,#flag=PFLAG_MURDERER)
                  AND NOT Send(eachObj,@CheckPlayerFlag,#flag=PFLAG_OUTLAW)
               {
                  Debug("Found non-enemy that was not healed yet");
				  oTarget = eachObj;
				  search = 6;
				  break;
               }
            break;
         }
         search++;
      }
	  
	  
      return oTarget;
   }

   
   %%%%%Projectile Configuration%%%%%
   GetProjectileSpeed()
   {
      if pbDebug = TRUE
      {
         return piDebugSpeed;   %Speed based on distance might look nice as well  - Speed 14 looks good at very long range, and 8 looks better at closer range
      }
     
      return 12;
   }
   
   GetProjectileLightFlags()
   {
      % General lighting information.
      if pbDebug = TRUE
     {
         if piLightFlags = 1 {return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;}
         if piLightFlags = 2 {return LIGHT_FLAG_ON | LIGHT_FLAG_WAVERING;}
         if piLightFlags = 3 {return LIGHT_FLAG_ON | LIGHT_FLAG_HIGHLIGHT;}
         if piLightFlags = 4 {return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC | LIGHT_FLAG_WAVERING;}
         if piLightFlags = 5 {return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC | LIGHT_FLAG_HIGHLIGHT;}
         if piLightFlags = 6 {return LIGHT_FLAG_ON | LIGHT_FLAG_WAVERING | LIGHT_FLAG_HIGHLIGHT;} %Looks the best (small orb)
                                                                                       %Might be able to generate multiple based on distance to have them chain out
         if piLightFlags > 6 {return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;}
     }
      return LIGHT_FLAG_ON | LIGHT_FLAG_DYNAMIC;
   }
   
   GetProjectileLightIntensity()
   {
      % Medium light radius for projectiles.  Out of 255 levels.
      return piIntensity;
   }

   GetProjectileLightColor()
   {
      local iColor;
     
      if pbDebug = TRUE
     {
         switch(piDebugColor)
         {
            case 1: iColor = LIGHT_BWHITE; break;
            case 2: iColor = LIGHT_WHITE; break;
            case 3: iColor = LIGHT_DWHITE; break;
            case 4: iColor = LIGHT_BYELLOW; break; %Looks the best
            case 5: iColor = LIGHT_YELLOW; break;
            case 6: iColor = LIGHT_DYELLOW; break;
            default : iColor = LIGHT_GREEN; break;
         }
      }
      return iColor;
   }
   
   SendProjectileAnimation()
   {
      AddPacket(1, ANIMATE_CYCLE, 4, 40, 2, 2, 2, 3);   % 40ms between animations
      return;
   }
   
end